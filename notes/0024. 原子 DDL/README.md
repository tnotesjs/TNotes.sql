# [0024. 原子 DDL](https://github.com/tnotesjs/TNotes.sql/tree/main/notes/0024.%20%E5%8E%9F%E5%AD%90%20DDL)

<!-- region:toc -->

- [1. 📝 概述](#1--概述)

<!-- endregion:toc -->

## 1. 📝 概述

- **原子 DDL（Atomic DDL）**
  - **原子 DDL（Atomic Data Definition Language）** 是 MySQL 8.0 引入的一项重要特性，它确保数据库的结构修改操作（如创建表、删除索引等）具有 **原子性**，即这些操作要么全部成功，要么全部失败回滚，不会停留在一个中间状态。
  - 原子 DDL 让数据库结构变更像事务一样安全可靠，不再担心“一半成功”的问题。
  - MySQL 8.0 支持原子数据定义语言（DDL）语句，此功能称为原子 DDL。
- **相关核心概念**

| 概念 | 解释 |
| --- | --- |
| **DDL** | 数据定义语言，用于定义或修改数据库结构的操作，例如：`CREATE`, `ALTER`, `DROP` 等。 |
| **原子性（Atomicity）** | 事务的四大特性之一，表示一组操作要么全部完成，要么完全不执行。 |

- MySQL 8.0 中的原子 DDL 就是将这些结构变更操作纳入事务机制中，从而保证其原子性。
- **🤔 为什么需要原子 DDL？**
  - 在 MySQL 8.0 之前：
    - DDL 操作不是事务性的。
    - 如果操作过程中发生错误（如崩溃），可能会留下部分更改的状态，比如：
      - 表已经创建，但索引未完成。
      - 文件系统中有残留文件。
    - 需要手动修复这些问题，维护成本高。
  - 而在 MySQL 8.0 及之后：
    - 所有 DDL 操作都通过**事务型数据字典**实现。
    - DDL 操作涉及的数据字典更新、存储引擎操作和二进制日志写入都被包装在一个事务中。
    - 出现异常时自动回滚，避免数据库处于“半更新”状态。
- **示例**

```sql
-- 创建一个新表，并添加索引
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100)
);

-- 添加一个索引（原子 DDL）
ALTER TABLE users
ADD INDEX idx_name (name);
/*
- 如果在添加索引的过程中服务器崩溃了，在重启后：
  - 如果事务已提交，则索引存在；
  - 如果事务未完成，则整个操作被回滚，表恢复到操作前的状态。
*/
```

- **关键技术支撑**

| 技术 | 描述 |
| --- | --- |
| **事务型数据字典** | MySQL 8.0 的核心改进，元数据信息统一存放在 InnoDB 引擎中，支持事务操作。 |
| **崩溃恢复一致性** | 原子 DDL 操作记录在事务日志中，即使崩溃也能恢复到一致状态。 |

- **特点**：
  - 成功则全部生效，失败则回滚，避免中间状态
  - 支持事务日志写入，确保崩溃恢复后的一致性
- **依赖技术**：基于新的事务型数据字典实现
- 原子 DDL 语句将与 DDL 操作关联的数据字典更新，存储引擎操作和二进制日志写入组合到单个原子事务中。
- 即使服务器在操作期间暂停，也会提交事务，并将适用的更改保留到数据字典、存储引擎和二进制日志，或者回滚事务。
- 通过在 MySQL 8.0 中引入 MySQL 数据字典，可以实现原子 DDL。
- 在早期的 MySQL 版本中，元数据存储在元数据文件、非事务性表和存储引擎特定的字典中，需要中间提交。
- MySQL 数据字典提供的集中式事务元数据存储消除了这一障碍，使得将 DDL 语句操作重组为原子事务成为可能。
