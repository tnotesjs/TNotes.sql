# [0026. 安全和账号管理](https://github.com/tnotesjs/TNotes.sql/tree/main/notes/0026.%20%E5%AE%89%E5%85%A8%E5%92%8C%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86)

<!-- region:toc -->

- [1. 📝 概述](#1--概述)
- [2. 📒 授权表存储引擎的变化](#2--授权表存储引擎的变化)
- [3. 📒 角色（Roles）支持](#3--角色roles支持)
- [4. 📒 密码策略与历史控制](#4--密码策略与历史控制)
- [5. 📒 双密码机制（Dual Password）](#5--双密码机制dual-password)

<!-- endregion:toc -->

## 1. 📝 概述

- MySQL 8.0 通过以下功能增强数据库的安全性，并在账户管理中实现更高的 DBA 灵活性。
  - MySQL 数据库的授权表统一为 InnoDB（事务性）表。每个语句都是事务性的，并且对所有创建的用户都是成功或者回滚，发生任何错误都无效。如果成功，就将语句写入二进制日志；如果失败则不写入，发生回滚并且不进行任何更改。
  - MySQL 8.0 开始支持角色，角色可以看成是一些权限的集合，为用户赋予统一的角色，权限的修改直接通过角色来进行，无须为每个用户单独授权。管理员可以创建和删除角色。
  - MySQL 8.0 开始维护有关密码历史的信息，从而限制了以前密码的重用。管理员可以在全局以及每个账户的基础上建立密码重用策略，从而在密码更改时限制使用以前使用过的密码。
  - MySQL 8.0 允许账户具有双密码，从而在多服务器系统中无缝地执行分阶段密码更改，无须停机。
- **授权表使用 InnoDB 存储**：所有权限操作具有事务性，支持回滚和提交。
- **支持角色（Roles）**：
  - 角色是一组权限集合
  - 可批量授予/回收权限，简化用户管理
- **密码策略与历史控制**：
  - 禁止重复使用旧密码
  - 支持全局或用户级别的密码重用限制
- **双密码机制**：
  - 允许用户拥有两个密码，便于在多个服务器之间平滑切换密码
- MySQL 8.0 在**安全性与账户管理**方面做了多项重大改进，提升了数据库的安全性、权限管理的灵活性和运维效率。

| 功能           | MySQL 8.0 之前         | MySQL 8.0                          |
| -------------- | ---------------------- | ---------------------------------- |
| 授权表存储引擎 | MyISAM（非事务）       | InnoDB（事务性）                   |
| 权限管理方式   | 单独授权每个用户       | 支持角色（Role）批量授权           |
| 密码策略       | 简单                   | 支持密码复杂度、历史记录、重用限制 |
| 密码变更       | 即时生效，可能中断连接 | 支持双密码机制，平滑过渡           |

## 2. 📒 授权表存储引擎的变化

- MySQL 8.0 之前
  - **授权表（如 `mysql.user`、`mysql.db` 等）使用 MyISAM 存储引擎**
  - 不支持事务，操作失败时可能导致数据不一致。
  - 权限修改是立即生效的，无法回滚。
  - 没有 ACID 支持，权限更改在崩溃后可能丢失或部分生效。
- MySQL 8.0 及之后
  - **授权表统一为 InnoDB 引擎**
  - 所有权限操作都具有事务性（ACID 特性）
  - 权限变更可以提交（COMMIT）或回滚（ROLLBACK）
  - 出现错误时自动回滚，保证一致性
  - 更改成功后才会写入二进制日志
  - **好处**：权限操作更安全、可恢复、并发控制更好。

## 3. 📒 角色（Roles）支持

- MySQL 8.0 之前
  - **没有角色机制**
  - 管理员必须对每个用户逐一授予权限
  - 权限变更复杂，维护成本高
  - 没有统一的权限集合概念
- MySQL 8.0 及之后
  - **引入角色（Role）**
  - 角色是一个 **权限集合**
  - 可以将角色授予多个用户
  - 修改角色权限 = 自动更新所有关联用户的权限
  - 支持启用/禁用某个角色
  - **好处**：权限管理更加模块化、简化了用户权限维护。
- 示例

```sql
-- 创建角色
CREATE ROLE developer;

-- 给角色赋权
GRANT SELECT, INSERT ON mydb.* TO developer;

-- 将角色赋予用户
GRANT developer TO user1;
```

## 4. 📒 密码策略与历史控制

- MySQL 8.0 之前
  - **密码策略简单**
  - 无内置强密码验证机制
  - 用户可以重复使用旧密码
  - 无法设置密码过期策略
- MySQL 8.0 及之后
  - **增强的密码管理功能**
  - 支持设置密码策略（如最小长度、复杂度等）
  - 支持密码历史记录（默认保留最近 5 个密码）
  - 可配置禁止重复使用旧密码（全局或单个用户级别）
  - **好处**：防止弱密码和密码复用，提升系统安全性。

```sql
-- 设置用户不能重复使用最近 5 次密码
ALTER USER 'user1'@'%' PASSWORD HISTORY 5;
```

## 5. 📒 双密码机制（Dual Password）

- **MySQL 8.0 的双密码机制允许你在不中断现有连接的前提下，安全地完成密码切换。你可以先设置新密码，让新旧密码共存一段时间，等应用配置全部更新后再清理旧密码。**
- MySQL 8.0 之前
  - **只能设置一个密码**
  - 修改密码会导致连接中断
  - 多服务器环境中切换密码需要停机或手动同步
- MySQL 8.0 及之后
  - **支持双密码机制**
  - 一个用户可以拥有两个密码 —— 主密码（Primary）和次密码（Secondary），**这俩密码均是有效的**。
    - 主密码 - 当前主要使用的密码
    - 次密码 - 同时有效的另一个密码
  - 新旧密码同时有效，便于逐步切换
  - 适用于主从复制、多实例部署场景
  - **好处**：实现无缝密码升级，避免服务中断。
- 示例

```sql
-- 设置双密码
SET PASSWORD FOR 'user1'@'%' = 'new_password';
-- 标记旧密码为已过期
RESET PASSWORD HISTORY FOR 'user1'@'%';
```

- 假设你有一个 Web 应用，连接数据库使用的账号是 `'app_user'@'%'`，密码是 `old_pass`。
- 应用服务器 A、B、C 正在使用 `old_pass` 连接数据库。
- DBA 设置了双密码：`SET PASSWORD FOR 'app_user'@'%' = 'new_pass';`
- 此时：
  - A、B、C 仍然使用 `old_pass`，可以正常连接。
  - 新部署的服务或重启后的服务可以使用 `new_pass`。
- 然后你逐个更新服务器上的数据库连接配置为 `new_pass`。
- 最后执行：`RESET PASSWORD HISTORY FOR 'app_user'@'%';`
  - 强制所有服务必须使用新密码连接。
